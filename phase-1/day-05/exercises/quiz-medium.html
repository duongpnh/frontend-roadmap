<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CSS Selectors & Cascade (Medium)</title>
  <style>
    /* ... (CSS Styles from original file) ... */
    :root {
      --bg: #0b1020;
      --card: #111834;
      --text: #e6eaf2;
      --muted: #9aa3b2;
      --primary: #4f46e5;
      --primary-600: #4338ca;
      --green: #16a34a;
      --red: #dc2626;
      --yellow: #f59e0b;
      --border: #1f2a4a;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--text);
      background: radial-gradient(1200px 800px at 80% -20%, #1c2350 0%, rgba(28, 35, 80, 0) 60%), radial-gradient(1000px 700px at -10% 110%, #1d274b 0%, rgba(29, 39, 75, 0) 60%), var(--bg);
      display: grid;
      place-items: center;
      padding: 24px;
    }

    .quiz-shell {
      width: 100%;
      max-width: 860px;
      display: grid;
      gap: 16px;
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .title {
      font-weight: 700;
      letter-spacing: 0.3px;
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 18px;
    }

    .title .badge {
      font-size: 12px;
      color: var(--yellow);
      background: rgba(245, 158, 11, 0.12);
      border: 1px solid rgba(245, 158, 11, 0.25);
      padding: 2px 8px;
      border-radius: 999px;
    }

    .progress {
      position: relative;
      height: 8px;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid var(--border);
      border-radius: 999px;
      overflow: hidden;
    }

    .progress>span {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--primary), #22c55e);
      transition: width 360ms ease;
    }

    .card {
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.01));
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.35);
      overflow: hidden;
      backdrop-filter: blur(8px);
      transform-origin: 50% 40%;
      animation: cardIn 420ms cubic-bezier(.2, .8, .2, 1);
    }

    @keyframes cardIn {
      from {
        opacity: 0;
        transform: translateY(12px) scale(0.985);
      }

      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .card-body {
      padding: 24px;
      display: grid;
      gap: 18px;
    }

    .q-head {
      display: grid;
      gap: 8px;
    }

    .q-index {
      font-size: 13px;
      color: var(--muted);
      letter-spacing: .3px;
    }

    .q-text {
      font-size: 20px;
      line-height: 1.45;
    }

    .options {
      display: grid;
      gap: 10px;
    }

    .option {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 14px 14px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid var(--border);
      border-radius: 12px;
      cursor: pointer;
      transition: transform 140ms ease, border-color 140ms ease, background 140ms ease;
      user-select: none;
    }

    .option:hover {
      transform: translateY(-1px);
      border-color: rgba(79, 70, 229, 0.55);
      background: rgba(79, 70, 229, 0.08);
    }

    .option.selected {
      border-color: rgba(255, 255, 255, 0.35);
    }

    .option.correct {
      border-color: rgba(34, 197, 94, 0.7);
      background: rgba(34, 197, 94, 0.08);
    }

    .option.incorrect {
      border-color: rgba(220, 38, 38, 0.7);
      background: rgba(220, 38, 38, 0.06);
    }

    .option .letter {
      width: 28px;
      height: 28px;
      border-radius: 999px;
      display: grid;
      place-items: center;
      font-weight: 700;
      font-size: 13px;
      color: var(--text);
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid var(--border);
      flex: 0 0 auto;
    }

    .explain {
      display: none;
      padding: 14px 16px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.02);
      animation: fadeIn 300ms ease;
    }

    .explain.show {
      display: block;
    }

    .explain.success {
      border-color: rgba(22, 163, 74, 0.6);
      background: rgba(22, 163, 74, 0.08);
    }

    .explain.error {
      border-color: rgba(220, 38, 38, 0.6);
      background: rgba(220, 38, 38, 0.08);
    }

    .explain .label {
      font-weight: 700;
      margin-bottom: 6px;
    }

    .explain.success .label {
      color: var(--green);
    }

    .explain.error .label {
      color: var(--red);
    }

    .explain pre {
      margin: 10px 0 0;
      padding: 12px;
      background: #0d1228;
      color: #e7ecf7;
      border: 1px solid #263156;
      border-radius: 10px;
      overflow: auto;
      max-height: 260px;
    }

    .footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 0 24px 24px;
    }

    .btn {
      appearance: none;
      border: 1px solid var(--border);
      background: var(--primary);
      color: white;
      padding: 10px 16px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      transition: transform 120ms ease, background 120ms ease, opacity 120ms ease;
    }

    .btn:hover {
      background: var(--primary-600);
      transform: translateY(-1px);
    }

    .btn:disabled {
      opacity: .5;
      cursor: not-allowed;
      transform: none;
    }

    .btn.ghost {
      background: transparent;
      color: var(--text);
      border-color: var(--border);
    }

    .meta {
      font-size: 13px;
      color: var(--muted);
    }

    .center {
      text-align: center;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(4px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Summary styles */
    .summary {
      display: grid;
      gap: 14px;
      padding: 24px;
      text-align: center;
    }

    .score {
      font-size: 42px;
      font-weight: 800;
      letter-spacing: .5px;
      background: linear-gradient(90deg, #22c55e, #4f46e5);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 12px;
    }

    .pill {
      border: 1px solid var(--border);
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.02);
    }

    @media (max-width: 720px) {
      .grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>

<body>
  <div class="quiz-shell">
    <div class="header">
      <div class="title">
        <span>CSS Selectors & Cascade (Medium)</span>
        <span class="badge">15 questions</span>
      </div>
      <div class="meta"><span id="meta-progress">0/15</span></div>
    </div>

    <div class="progress"><span id="progress-bar"></span></div>

    <section id="stage" class="card" aria-live="polite"></section>
  </div>

  <script>
    const LETTERS = ["A", "B", "C", "D"];

    const quizData = [
      {
        q: "Bộ chọn nào sau đây chọn tất cả các thẻ `<a>` là *con trực tiếp* (direct child) của thẻ `<ul>`?",
        options: [
          "ul a",
          "ul > a",
          "ul ~ a",
          "ul + a"
        ],
        correctIndex: 1,
        explanation: "Bộ chọn con trực tiếp (Child Selector) sử dụng dấu lớn hơn (>) để chỉ chọn phần tử con ở cấp độ đầu tiên.",
        example: "ul > li { color: blue; }"
      },
      {
        q: "Tính độ đặc hiệu của bộ chọn sau: `.nav-item a:hover`",
        options: [
          "(0, 1, 1, 0)",
          "(0, 2, 1, 0)",
          "(1, 0, 1, 0)",
          "(0, 2, 0, 0)"
        ],
        correctIndex: 1,
        explanation: "Điểm: 1 Class (.nav-item) + 1 Pseudo-class (:hover) + 1 Element (a) = (0, 2, 1, 0). (Pseudo-class được tính điểm như Class)."
      },
      {
        q: "Trong quy trình Cascade, yếu tố nào được xem xét *trước* cả Độ Đặc Hiệu và Thứ Tự Nguồn?",
        options: [
          "Tên thuộc tính",
          "Giá trị thuộc tính",
          "Nguồn gốc của quy tắc (Origin)",
          "Độ dài của mã CSS"
        ],
        correctIndex: 2,
        explanation: "Origin (Tác giả, Người dùng, Trình duyệt) là yếu tố đầu tiên và quan trọng nhất quyết định ưu tiên của một quy tắc CSS."
      },
      {
        q: "Bộ chọn thuộc tính (Attribute Selector) nào sẽ chọn tất cả các thẻ `<a>` có thuộc tính `target=\"_blank\"`?",
        options: [
          "a:target=\"_blank\"",
          "a[target=\"_blank\"]",
          "a.target=\"_blank\"",
          "a[target=_blank]"
        ],
        correctIndex: 1,
        explanation: "Dùng cặp dấu ngoặc vuông `[]` để chỉ định bộ chọn thuộc tính. Cặp dấu ngoặc đơn quanh giá trị là tùy chọn, nhưng tốt nhất nên dùng."
      },
      {
        q: "Bộ chọn Sibling (Anh/Chị/Em) **Adjacent** (`+`) có tác dụng gì?",
        options: [
          "Chọn tất cả các phần tử anh em",
          "Chọn phần tử con trực tiếp đầu tiên",
          "Chọn phần tử anh em *kế tiếp ngay sau* nó",
          "Chọn phần tử cha"
        ],
        correctIndex: 2,
        explanation: "`A + B` chọn phần tử `B` nằm ngay sau `A` và cùng cấp độ (sibling). Nếu là `~` sẽ chọn tất cả các sibling nằm sau."
      },
      {
        q: "Điều gì sẽ xảy ra nếu bạn cố gắng ghi đè một quy tắc `!important` bằng một quy tắc không có `!important`?",
        options: [
          "Quy tắc không `!important` sẽ thắng",
          "Quy tắc `!important` sẽ thắng",
          "Cả hai bị hủy bỏ",
          "Tùy thuộc vào độ đặc hiệu"
        ],
        correctIndex: 1,
        explanation: "Khai báo `!important` có độ ưu tiên cực cao, nó chỉ bị ghi đè bởi một khai báo `!important` khác với độ ưu tiên cao hơn (hoặc cùng Origin nhưng viết sau)."
      },
      {
        q: "Giả sử bạn có `<p id=\"first\">` và `<p class=\"second\">` liên tiếp nhau. Bộ chọn nào sau đây sẽ chọn thẻ `<p>` thứ hai?",
        options: [
          "p:first-child",
          "p + p",
          "#first p",
          "p:nth-of-type(2)"
        ],
        correctIndex: 1,
        explanation: "`p + p` sử dụng Adjacent Sibling Selector để chọn thẻ `<p>` nằm ngay sau một thẻ `<p>` khác."
      },
      {
        q: "Pseudo-class `:nth-child(2)` chọn phần tử nào?",
        options: [
          "Phần tử thứ hai của loại đó",
          "Phần tử có giá trị 2",
          "Phần tử thứ hai bất kể loại",
          "Phần tử cha của nó"
        ],
        correctIndex: 2,
        explanation: "`:nth-child(n)` đếm vị trí thứ n trong số *tất cả* các phần tử con của phần tử cha, sau đó kiểm tra xem phần tử đó có khớp với Selector Type không."
      },
      {
        q: "Quy tắc CSS nào có độ đặc hiệu (Specificity Score) là (1, 0, 0, 0)?",
        options: [
          "p",
          ".main-nav",
          "#sidebar",
          "div:not(p)"
        ],
        correctIndex: 2,
        explanation: "(1, 0, 0, 0) là điểm số dành cho ID Selector (#sidebar)."
      },
      {
        q: "Tại sao việc sử dụng CSS Inline Style (`style=\"\"`) thường bị coi là kém (Bad Practice)?",
        options: [
          "Làm tăng kích thước file CSS",
          "Ảnh hưởng đến khả năng Responsive",
          "Có độ đặc hiệu quá cao, khiến khó ghi đè",
          "Dễ bị ghi đè bởi CSS bên ngoài"
        ],
        correctIndex: 2,
        explanation: "Inline Style có độ đặc hiệu cực cao, làm cho việc quản lý và duy trì kiểu dáng tập trung (separation of concerns) trở nên khó khăn."
      },
      {
        q: "Bộ chọn thuộc tính `[title~=\"nav\"]` sẽ chọn phần tử có thuộc tính `title` như thế nào?",
        options: [
          "Bắt đầu bằng 'nav'",
          "Kết thúc bằng 'nav'",
          "Chứa từ 'nav' như một từ độc lập trong danh sách dấu cách",
          "Bằng chính xác 'nav'"
        ],
        correctIndex: 2,
        explanation: "`~=` (Tilde Equals) chọn thuộc tính chứa một từ được phân tách bằng dấu cách trong danh sách giá trị thuộc tính. Ví dụ: `title=\"main nav bar\"` sẽ khớp."
      },
      {
        q: "Thuộc tính nào trong CSS không được kế thừa (non-inherited) từ phần tử cha sang phần tử con?",
        options: [
          "color",
          "font-family",
          "border",
          "text-align"
        ],
        correctIndex: 2,
        explanation: "Các thuộc tính hộp (Box Model) như `border`, `margin`, `padding`, `width`, `height`... không được kế thừa."
      },
      {
        q: "Độ đặc hiệu của bộ chọn Attribute `[id=\"my-id\"]` so với ID Selector `#my-id` là:",
        options: [
          "Attribute Selector cao hơn ID Selector",
          "ID Selector cao hơn Attribute Selector",
          "Bằng nhau",
          "Không thể so sánh"
        ],
        correctIndex: 1,
        explanation: "ID Selector (#my-id) là (1,0,0,0). Attribute Selector ([id=\"my-id\"]) là (0,1,0,0). Do đó ID Selector có ưu tiên cao hơn."
      },
      {
        q: "Điều gì xảy ra khi bạn đặt `all: initial;` cho một phần tử?",
        options: [
          "Xóa tất cả thuộc tính của phần tử",
          "Đặt tất cả thuộc tính về giá trị mặc định ban đầu của trình duyệt",
          "Đặt tất cả thuộc tính về giá trị kế thừa",
          "Chỉ reset `display` và `visibility`"
        ],
        correctIndex: 1,
        explanation: "`initial` đặt tất cả các thuộc tính của phần tử về giá trị mặc định ban đầu (User Agent Styles) của chúng."
      },
      {
        q: "Bộ chọn giả phần tử (Pseudo-element) nào dùng để tạo kiểu cho ký tự *đầu tiên* của một đoạn văn bản?",
        options: [
          ":first-child",
          "p::first-child",
          "p::first-letter",
          ":first-line"
        ],
        correctIndex: 2,
        explanation: "Sử dụng `::` để chỉ Pseudo-element. `::first-letter` dùng để tạo kiểu cho ký tự đầu tiên của khối văn bản."
      }
    ];

    const stage = document.getElementById("stage");
    const progressBar = document.getElementById("progress-bar");
    const metaProgress = document.getElementById("meta-progress");

    let order = [];
    let current = 0;
    let score = 0;
    let answered = false;

    function shuffle(arr) {
      const a = [...arr];
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function escapeHtml(str) {
      return str.replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;");
    }

    function setProgress() {
      metaProgress.textContent = `${Math.min(current + 1, order.length)}/${order.length}`;
      const pct = (current) / order.length * 100;
      progressBar.style.width = `${pct}%`;
    }

    function renderQuestion() {
      const q = quizData[order[current]];

      const options = q.options.map((text, i) => {
        return `<div class="option" data-index="${i}" role="button" tabindex="0" aria-pressed="false">
  <div class="letter">${LETTERS[i]}</div>
  <div>${escapeHtml(text)}</div>
</div>`;
      }).join("");

      stage.innerHTML = `
        <div class="card-body">
          <div class="q-head">
            <div class="q-index">Câu ${current + 1}/${order.length}</div>
            <div class="q-text">${escapeHtml(q.q)}</div>
          </div>
          <div class="options" id="options">${options}</div>
          <div id="explain" class="explain" aria-live="polite"></div>
        </div>
        <div class="footer">
          <button id="resetBtn" class="btn ghost">Reset</button>
          <div style="display:flex; gap:10px; align-items:center">
            <span class="meta" id="hint">${answered ? "Chọn đáp án để xem giải thích" : ""}</span>
            <button id="nextBtn" class="btn" disabled>Tiếp theo</button>
          </div>
        </div>
      `;

      answered = false;
      bindHandlers();
      setProgress();
    }

    function bindHandlers() {
      const q = quizData[order[current]];
      const list = stage.querySelectorAll(".option");
      const explainBox = stage.querySelector("#explain");
      const nextBtn = stage.querySelector("#nextBtn");
      const resetBtn = stage.querySelector("#resetBtn");

      list.forEach(el => {
        const idx = Number(el.getAttribute("data-index"));
        const select = () => {
          if (answered) return;
          answered = true;

          list.forEach(n => n.classList.remove("selected"));
          el.classList.add("selected");

          const isCorrect = idx === q.correctIndex;
          if (isCorrect) {
            el.classList.add("correct");
            score += 1;
          } else {
            el.classList.add("incorrect");
            const correctEl = Array.from(list)[q.correctIndex];
            correctEl.classList.add("correct");
          }

          const label = isCorrect ? "Chính xác!" : "Chưa chính xác";
          const cls = isCorrect ? "success" : "error";
          const exampleBlock = q.example ? `<pre><code>${escapeHtml(q.example)}</code></pre>` : "";

          explainBox.className = `explain show ${cls}`;
          explainBox.innerHTML = `<div class="label">${label}</div><div>${escapeHtml(q.explanation)}</div>${exampleBlock}`;

          nextBtn.disabled = false;
        };

        el.addEventListener("click", select);
        el.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            select();
          }
        });
      });

      nextBtn.addEventListener("click", nextStep);
      resetBtn.addEventListener("click", resetQuiz);
    }

    function nextStep() {
      if (current < order.length - 1) {
        current += 1;
        renderQuestion();
      } else {
        showSummary();
      }
    }

    function showSummary() {
      progressBar.style.width = "100%";
      metaProgress.textContent = `${order.length}/${order.length}`;

      stage.innerHTML = `
        <div class="summary">
          <div class="score">${score}/${order.length}</div>
          <div class="grid">
            <div class="pill">Đúng: <strong style="color: var(--green)">${score}</strong></div>
            <div class="pill">Sai: <strong style="color: var(--red)">${order.length - score}</strong></div>
          </div>
          <div class="meta">Hoàn thành quiz về CSS Selectors & Cascade. Bạn có thể làm lại để luyện tập thêm.</div>
          <div style="display:flex; justify-content:center; gap:12px; margin-top: 4px;">
            <button class="btn" id="again">Làm lại</button>
          </div>
        </div>
      `;

      const again = document.getElementById("again");
      again.addEventListener("click", resetQuiz);
    }

    function resetQuiz() {
      order = shuffle(quizData.map((_, i) => i));
      current = 0;
      score = 0;
      answered = false;
      renderQuestion();
    }

    // init
    resetQuiz();
  </script>
</body>

</html>
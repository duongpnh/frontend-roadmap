<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CSS Selectors & Cascade (Basic)</title>
  <style>
    /* ... (CSS Styles from original file) ... */
    :root {
      --bg: #0b1020;
      --card: #111834;
      --text: #e6eaf2;
      --muted: #9aa3b2;
      --primary: #4f46e5;
      --primary-600: #4338ca;
      --green: #16a34a;
      --red: #dc2626;
      --yellow: #f59e0b;
      --border: #1f2a4a;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--text);
      background: radial-gradient(1200px 800px at 80% -20%, #1c2350 0%, rgba(28, 35, 80, 0) 60%), radial-gradient(1000px 700px at -10% 110%, #1d274b 0%, rgba(29, 39, 75, 0) 60%), var(--bg);
      display: grid;
      place-items: center;
      padding: 24px;
    }

    .quiz-shell {
      width: 100%;
      max-width: 860px;
      display: grid;
      gap: 16px;
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .title {
      font-weight: 700;
      letter-spacing: 0.3px;
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 18px;
    }

    .title .badge {
      font-size: 12px;
      color: var(--yellow);
      background: rgba(245, 158, 11, 0.12);
      border: 1px solid rgba(245, 158, 11, 0.25);
      padding: 2px 8px;
      border-radius: 999px;
    }

    .progress {
      position: relative;
      height: 8px;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid var(--border);
      border-radius: 999px;
      overflow: hidden;
    }

    .progress>span {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--primary), #22c55e);
      transition: width 360ms ease;
    }

    .card {
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.01));
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.35);
      overflow: hidden;
      backdrop-filter: blur(8px);
      transform-origin: 50% 40%;
      animation: cardIn 420ms cubic-bezier(.2, .8, .2, 1);
    }

    @keyframes cardIn {
      from {
        opacity: 0;
        transform: translateY(12px) scale(0.985);
      }

      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .card-body {
      padding: 24px;
      display: grid;
      gap: 18px;
    }

    .q-head {
      display: grid;
      gap: 8px;
    }

    .q-index {
      font-size: 13px;
      color: var(--muted);
      letter-spacing: .3px;
    }

    .q-text {
      font-size: 20px;
      line-height: 1.45;
    }

    .options {
      display: grid;
      gap: 10px;
    }

    .option {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 14px 14px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid var(--border);
      border-radius: 12px;
      cursor: pointer;
      transition: transform 140ms ease, border-color 140ms ease, background 140ms ease;
      user-select: none;
    }

    .option:hover {
      transform: translateY(-1px);
      border-color: rgba(79, 70, 229, 0.55);
      background: rgba(79, 70, 229, 0.08);
    }

    .option.selected {
      border-color: rgba(255, 255, 255, 0.35);
    }

    .option.correct {
      border-color: rgba(34, 197, 94, 0.7);
      background: rgba(34, 197, 94, 0.08);
    }

    .option.incorrect {
      border-color: rgba(220, 38, 38, 0.7);
      background: rgba(220, 38, 38, 0.06);
    }

    .option .letter {
      width: 28px;
      height: 28px;
      border-radius: 999px;
      display: grid;
      place-items: center;
      font-weight: 700;
      font-size: 13px;
      color: var(--text);
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid var(--border);
      flex: 0 0 auto;
    }

    .explain {
      display: none;
      padding: 14px 16px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.02);
      animation: fadeIn 300ms ease;
    }

    .explain.show {
      display: block;
    }

    .explain.success {
      border-color: rgba(22, 163, 74, 0.6);
      background: rgba(22, 163, 74, 0.08);
    }

    .explain.error {
      border-color: rgba(220, 38, 38, 0.6);
      background: rgba(220, 38, 38, 0.08);
    }

    .explain .label {
      font-weight: 700;
      margin-bottom: 6px;
    }

    .explain.success .label {
      color: var(--green);
    }

    .explain.error .label {
      color: var(--red);
    }

    .explain pre {
      margin: 10px 0 0;
      padding: 12px;
      background: #0d1228;
      color: #e7ecf7;
      border: 1px solid #263156;
      border-radius: 10px;
      overflow: auto;
      max-height: 260px;
    }

    .footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 0 24px 24px;
    }

    .btn {
      appearance: none;
      border: 1px solid var(--border);
      background: var(--primary);
      color: white;
      padding: 10px 16px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      transition: transform 120ms ease, background 120ms ease, opacity 120ms ease;
    }

    .btn:hover {
      background: var(--primary-600);
      transform: translateY(-1px);
    }

    .btn:disabled {
      opacity: .5;
      cursor: not-allowed;
      transform: none;
    }

    .btn.ghost {
      background: transparent;
      color: var(--text);
      border-color: var(--border);
    }

    .meta {
      font-size: 13px;
      color: var(--muted);
    }

    .center {
      text-align: center;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(4px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Summary styles */
    .summary {
      display: grid;
      gap: 14px;
      padding: 24px;
      text-align: center;
    }

    .score {
      font-size: 42px;
      font-weight: 800;
      letter-spacing: .5px;
      background: linear-gradient(90deg, #22c55e, #4f46e5);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 12px;
    }

    .pill {
      border: 1px solid var(--border);
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.02);
    }

    @media (max-width: 720px) {
      .grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>

<body>
  <div class="quiz-shell">
    <div class="header">
      <div class="title">
        <span>CSS Selectors & Cascade (Basic)</span>
        <span class="badge">15 questions</span>
      </div>
      <div class="meta"><span id="meta-progress">0/15</span></div>
    </div>

    <div class="progress"><span id="progress-bar"></span></div>

    <section id="stage" class="card" aria-live="polite"></section>
  </div>

  <script>
    const LETTERS = ["A", "B", "C", "D"];

    const quizData = [
      {
        q: "Bộ chọn (Selector) nào được dùng để chọn *tất cả* các phần tử trên trang HTML?",
        options: [
          ".all",
          "#all",
          "*",
          "body"
        ],
        correctIndex: 2,
        explanation: "Bộ chọn Universal (*) được dùng để áp dụng kiểu dáng cho mọi phần tử. Nó có độ đặc hiệu thấp nhất.",
        example: "* { margin: 0; padding: 0; }"
      },
      {
        q: "Để chọn một phần tử có thuộc tính `class=\"primary-btn\"`, bạn sẽ dùng bộ chọn nào?",
        options: [
          "primary-btn",
          "#primary-btn",
          ".primary-btn",
          "button"
        ],
        correctIndex: 2,
        explanation: "Dấu chấm (.) đứng trước tên class là quy tắc chuẩn của Class Selector, có độ đặc hiệu (0, 1, 0, 0)."
      },
      {
        q: "Bộ chọn nào trong CSS có độ đặc hiệu (Specificity) cao nhất trong 3 loại: ID, Class, Element?",
        options: [
          "Class Selector",
          "ID Selector",
          "Element Selector",
          "Cả ba bằng nhau"
        ],
        correctIndex: 1,
        explanation: "ID Selector có điểm (1, 0, 0, 0), luôn cao hơn Class (0, 1, 0, 0) và Element (0, 0, 1, 0)."
      },
      {
        q: "Khi hai quy tắc CSS khác nhau nhắm vào cùng một phần tử nhưng có độ đặc hiệu bằng nhau, quy tắc nào sẽ được áp dụng?",
        options: [
          "Quy tắc đầu tiên",
          "Quy tắc có nhiều thuộc tính hơn",
          "Quy tắc được khai báo sau cùng",
          "Quy tắc không có lỗi cú pháp"
        ],
        correctIndex: 2,
        explanation: "Đây là quy tắc Source Order (Thứ tự nguồn). Quy tắc được khai báo sau cùng sẽ ghi đè các quy tắc trước đó có cùng độ đặc hiệu."
      },
      {
        q: "Bạn muốn đặt màu nền cho tất cả các đoạn văn bản (`<p>`). Bạn dùng bộ chọn nào?",
        options: [
          "p.color",
          ".p",
          "p",
          "#p"
        ],
        correctIndex: 2,
        explanation: "Sử dụng tên thẻ (Type Selector) `p` là cách đơn giản nhất để chọn tất cả các phần tử cùng loại đó."
      },
      {
        q: "Nếu bạn muốn chọn một phần tử *duy nhất* trên trang, bạn nên sử dụng bộ chọn nào?",
        options: [
          "Class Selector",
          "Element Selector",
          "Universal Selector",
          "ID Selector"
        ],
        correctIndex: 3,
        explanation: "Thuộc tính ID phải là duy nhất trên trang HTML, do đó ID Selector (#id) chỉ nên chọn một phần tử duy nhất."
      },
      {
        q: "Thuộc tính `color: blue !important;` có tác dụng gì?",
        options: [
          "Bắt buộc trình duyệt bỏ qua quy tắc này",
          "Bắt buộc trình duyệt chuyển sang màu xanh lá",
          "Tăng độ ưu tiên của quy tắc lên mức cao nhất, ghi đè độ đặc hiệu",
          "Giảm độ ưu tiên của quy tắc"
        ],
        correctIndex: 2,
        explanation: "`!important` là một công cụ mạnh mẽ để tăng cường ưu tiên của một khai báo CSS, nhưng nên tránh lạm dụng."
      },
      {
        q: "Trong bộ chọn `nav a`, `a` được gọi là gì so với `nav`?",
        options: [
          "Selector Class",
          "Selector Child (Con trực tiếp)",
          "Selector Descendant (Hậu duệ)",
          "Selector Sibling (Anh em)"
        ],
        correctIndex: 2,
        explanation: "Bộ chọn hậu duệ (Descendant Selector) chọn thẻ `<a>` nằm bên trong (hậu duệ) của thẻ `<nav>`, bất kể cấp độ sâu."
      },
      {
        q: "Nếu một phần tử không có khai báo màu chữ (`color`) riêng, nó sẽ nhận màu chữ từ đâu?",
        options: [
          "Mặc định của trình duyệt",
          "Phần tử cha gần nhất",
          "Phần tử con đầu tiên",
          "Thẻ `<html>`"
        ],
        correctIndex: 1,
        explanation: "Thuộc tính `color` là thuộc tính được kế thừa (Inherited), nghĩa là nó nhận giá trị từ phần tử cha của nó."
      },
      {
        q: "Bộ chọn giả lớp (Pseudo-class) nào thường được sử dụng để áp dụng kiểu dáng khi người dùng di chuột qua một phần tử?",
        options: [
          ":active",
          ":focus",
          ":link",
          ":hover"
        ],
        correctIndex: 3,
        explanation: "Pseudo-class `:hover` được kích hoạt khi con trỏ chuột ở trên phần tử, thường dùng để tạo hiệu ứng tương tác."
      },
      {
        q: "Quy tắc `h2 { font-size: 20px; }` có độ đặc hiệu (Specificity Score) là bao nhiêu?",
        options: [
          "(0, 0, 0, 1)",
          "(0, 0, 1, 0)",
          "(0, 1, 0, 0)",
          "(1, 0, 0, 0)"
        ],
        correctIndex: 0,
        explanation: "Type Selector (h2) được tính là (0, 0, 0, 1) theo cấu trúc (Inline Style, ID Selector, Class/Pseudo-class, Element/Pseudo-element)."
      },
      {
        q: "Làm thế nào để áp dụng kiểu dáng CSS trực tiếp vào thẻ HTML?",
        options: [
          "Dùng thẻ `<style>`",
          "Dùng thuộc tính `style` bên trong thẻ",
          "Dùng thuộc tính `css`",
          "Dùng thẻ `<link>`"
        ],
        correctIndex: 1,
        explanation: "Đây là CSS Inline Style. Ví dụ: `<p style='color: red;'>...</p>`. Nó có độ đặc hiệu rất cao (1, 0, 0, 0)."
      },
      {
        q: "Nếu bạn đặt `font-size: 16px;` ở đầu file CSS và sau đó đặt `font-size: 20px;` ở cuối file cho cùng một bộ chọn, cỡ chữ sẽ là bao nhiêu?",
        options: [
          "16px",
          "20px",
          "Mặc định trình duyệt",
          "Cả hai không hoạt động"
        ],
        correctIndex: 1,
        explanation: "Theo quy tắc Source Order (Thứ tự nguồn), quy tắc được khai báo sau cùng (20px) sẽ được ưu tiên áp dụng."
      },
      {
        q: "Bộ chọn `* a` sẽ chọn những phần tử nào?",
        options: [
          "Chỉ các thẻ `<a>` nằm ngoài bất kỳ thẻ nào khác",
          "Chỉ thẻ `<a>` là con trực tiếp của `<body>`",
          "Tất cả các thẻ `<a>` là hậu duệ của bất kỳ phần tử nào",
          "Chỉ thẻ `<a>` có class là `*`"
        ],
        correctIndex: 2,
        explanation: "Bộ chọn Descendant `* a` thực chất giống với `a`, vì `*` đại diện cho bất kỳ phần tử nào. Nó chọn tất cả thẻ liên kết."
      },
      {
        q: "Khái niệm **Cascade** (Thứ tự ưu tiên) trong CSS được dùng để giải quyết vấn đề gì?",
        options: [
          "Xác định cấu trúc HTML",
          "Quyết định quy tắc CSS nào được áp dụng khi có xung đột",
          "Tăng tốc độ tải trang",
          "Phân loại các loại font chữ"
        ],
        correctIndex: 1,
        explanation: "Cascade là thuật toán cốt lõi của CSS để xác định khai báo giá trị cuối cùng cho một thuộc tính của một phần tử."
      }
    ];

    const stage = document.getElementById("stage");
    const progressBar = document.getElementById("progress-bar");
    const metaProgress = document.getElementById("meta-progress");

    let order = [];
    let current = 0;
    let score = 0;
    let answered = false;

    function shuffle(arr) {
      const a = [...arr];
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function escapeHtml(str) {
      return str.replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;");
    }

    function setProgress() {
      metaProgress.textContent = `${Math.min(current + 1, order.length)}/${order.length}`;
      const pct = (current) / order.length * 100;
      progressBar.style.width = `${pct}%`;
    }

    function renderQuestion() {
      const q = quizData[order[current]];

      const options = q.options.map((text, i) => {
        return `<div class="option" data-index="${i}" role="button" tabindex="0" aria-pressed="false">
  <div class="letter">${LETTERS[i]}</div>
  <div>${escapeHtml(text)}</div>
</div>`;
      }).join("");

      stage.innerHTML = `
        <div class="card-body">
          <div class="q-head">
            <div class="q-index">Câu ${current + 1}/${order.length}</div>
            <div class="q-text">${escapeHtml(q.q)}</div>
          </div>
          <div class="options" id="options">${options}</div>
          <div id="explain" class="explain" aria-live="polite"></div>
        </div>
        <div class="footer">
          <button id="resetBtn" class="btn ghost">Reset</button>
          <div style="display:flex; gap:10px; align-items:center">
            <span class="meta" id="hint">${answered ? "Chọn đáp án để xem giải thích" : ""}</span>
            <button id="nextBtn" class="btn" disabled>Tiếp theo</button>
          </div>
        </div>
      `;

      answered = false;
      bindHandlers();
      setProgress();
    }

    function bindHandlers() {
      const q = quizData[order[current]];
      const list = stage.querySelectorAll(".option");
      const explainBox = stage.querySelector("#explain");
      const nextBtn = stage.querySelector("#nextBtn");
      const resetBtn = stage.querySelector("#resetBtn");

      list.forEach(el => {
        const idx = Number(el.getAttribute("data-index"));
        const select = () => {
          if (answered) return;
          answered = true;

          list.forEach(n => n.classList.remove("selected"));
          el.classList.add("selected");

          const isCorrect = idx === q.correctIndex;
          if (isCorrect) {
            el.classList.add("correct");
            score += 1;
          } else {
            el.classList.add("incorrect");
            const correctEl = Array.from(list)[q.correctIndex];
            correctEl.classList.add("correct");
          }

          const label = isCorrect ? "Chính xác!" : "Chưa chính xác";
          const cls = isCorrect ? "success" : "error";
          const exampleBlock = q.example ? `<pre><code>${escapeHtml(q.example)}</code></pre>` : "";

          explainBox.className = `explain show ${cls}`;
          explainBox.innerHTML = `<div class="label">${label}</div><div>${escapeHtml(q.explanation)}</div>${exampleBlock}`;

          nextBtn.disabled = false;
        };

        el.addEventListener("click", select);
        el.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            select();
          }
        });
      });

      nextBtn.addEventListener("click", nextStep);
      resetBtn.addEventListener("click", resetQuiz);
    }

    function nextStep() {
      if (current < order.length - 1) {
        current += 1;
        renderQuestion();
      } else {
        showSummary();
      }
    }

    function showSummary() {
      progressBar.style.width = "100%";
      metaProgress.textContent = `${order.length}/${order.length}`;

      stage.innerHTML = `
        <div class="summary">
          <div class="score">${score}/${order.length}</div>
          <div class="grid">
            <div class="pill">Đúng: <strong style="color: var(--green)">${score}</strong></div>
            <div class="pill">Sai: <strong style="color: var(--red)">${order.length - score}</strong></div>
          </div>
          <div class="meta">Hoàn thành quiz về CSS Selectors & Cascade. Bạn có thể làm lại để luyện tập thêm.</div>
          <div style="display:flex; justify-content:center; gap:12px; margin-top: 4px;">
            <button class="btn" id="again">Làm lại</button>
          </div>
        </div>
      `;

      const again = document.getElementById("again");
      again.addEventListener("click", resetQuiz);
    }

    function resetQuiz() {
      order = shuffle(quizData.map((_, i) => i));
      current = 0;
      score = 0;
      answered = false;
      renderQuestion();
    }

    // init
    resetQuiz();
  </script>
</body>

</html>
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HTML Form Quiz</title>
  <style>
    :root {
      --bg: #0b1020;
      --card: #111834;
      --text: #e6eaf2;
      --muted: #9aa3b2;
      --primary: #4f46e5;
      --primary-600: #4338ca;
      --green: #16a34a;
      --red: #dc2626;
      --yellow: #f59e0b;
      --border: #1f2a4a;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--text);
      background: radial-gradient(1200px 800px at 80% -20%, #1c2350 0%, rgba(28, 35, 80, 0) 60%), radial-gradient(1000px 700px at -10% 110%, #1d274b 0%, rgba(29, 39, 75, 0) 60%), var(--bg);
      display: grid;
      place-items: center;
      padding: 24px;
    }

    .quiz-shell {
      width: 100%;
      max-width: 860px;
      display: grid;
      gap: 16px;
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .title {
      font-weight: 700;
      letter-spacing: 0.3px;
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 18px;
    }

    .title .badge {
      font-size: 12px;
      color: var(--yellow);
      background: rgba(245, 158, 11, 0.12);
      border: 1px solid rgba(245, 158, 11, 0.25);
      padding: 2px 8px;
      border-radius: 999px;
    }

    .progress {
      position: relative;
      height: 8px;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid var(--border);
      border-radius: 999px;
      overflow: hidden;
    }

    .progress>span {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--primary), #22c55e);
      transition: width 360ms ease;
    }

    .card {
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.01));
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.35);
      overflow: hidden;
      backdrop-filter: blur(8px);
      transform-origin: 50% 40%;
      animation: cardIn 420ms cubic-bezier(.2, .8, .2, 1);
    }

    @keyframes cardIn {
      from {
        opacity: 0;
        transform: translateY(12px) scale(0.985);
      }

      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .card-body {
      padding: 24px;
      display: grid;
      gap: 18px;
    }

    .q-head {
      display: grid;
      gap: 8px;
    }

    .q-index {
      font-size: 13px;
      color: var(--muted);
      letter-spacing: .3px;
    }

    .q-text {
      font-size: 20px;
      line-height: 1.45;
    }

    .options {
      display: grid;
      gap: 10px;
    }

    .option {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 14px 14px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid var(--border);
      border-radius: 12px;
      cursor: pointer;
      transition: transform 140ms ease, border-color 140ms ease, background 140ms ease;
      user-select: none;
    }

    .option:hover {
      transform: translateY(-1px);
      border-color: rgba(79, 70, 229, 0.55);
      background: rgba(79, 70, 229, 0.08);
    }

    .option.selected {
      border-color: rgba(255, 255, 255, 0.35);
    }

    .option.correct {
      border-color: rgba(34, 197, 94, 0.7);
      background: rgba(34, 197, 94, 0.08);
    }

    .option.incorrect {
      border-color: rgba(220, 38, 38, 0.7);
      background: rgba(220, 38, 38, 0.06);
    }

    .option .letter {
      width: 28px;
      height: 28px;
      border-radius: 999px;
      display: grid;
      place-items: center;
      font-weight: 700;
      font-size: 13px;
      color: var(--text);
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid var(--border);
      flex: 0 0 auto;
    }

    .explain {
      display: none;
      padding: 14px 16px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.02);
      animation: fadeIn 300ms ease;
    }

    .explain.show {
      display: block;
    }

    .explain.success {
      border-color: rgba(22, 163, 74, 0.6);
      background: rgba(22, 163, 74, 0.08);
    }

    .explain.error {
      border-color: rgba(220, 38, 38, 0.6);
      background: rgba(220, 38, 38, 0.08);
    }

    .explain .label {
      font-weight: 700;
      margin-bottom: 6px;
    }

    .explain.success .label {
      color: var(--green);
    }

    .explain.error .label {
      color: var(--red);
    }

    .explain pre {
      margin: 10px 0 0;
      padding: 12px;
      background: #0d1228;
      color: #e7ecf7;
      border: 1px solid #263156;
      border-radius: 10px;
      overflow: auto;
      max-height: 260px;
    }

    .footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 0 24px 24px;
    }

    .btn {
      appearance: none;
      border: 1px solid var(--border);
      background: var(--primary);
      color: white;
      padding: 10px 16px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      transition: transform 120ms ease, background 120ms ease, opacity 120ms ease;
    }

    .btn:hover {
      background: var(--primary-600);
      transform: translateY(-1px);
    }

    .btn:disabled {
      opacity: .5;
      cursor: not-allowed;
      transform: none;
    }

    .btn.ghost {
      background: transparent;
      color: var(--text);
      border-color: var(--border);
    }

    .meta {
      font-size: 13px;
      color: var(--muted);
    }

    .center {
      text-align: center;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(4px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Summary styles */
    .summary {
      display: grid;
      gap: 14px;
      padding: 24px;
      text-align: center;
    }

    .score {
      font-size: 42px;
      font-weight: 800;
      letter-spacing: .5px;
      background: linear-gradient(90deg, #22c55e, #4f46e5);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 12px;
    }

    .pill {
      border: 1px solid var(--border);
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.02);
    }

    @media (max-width: 720px) {
      .grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>

<body>
  <div class="quiz-shell">
    <div class="header">
      <div class="title">
        <span>HTML Form Quiz</span>
        <span class="badge">15 questions</span>
      </div>
      <div class="meta"><span id="meta-progress">0/15</span></div>
    </div>

    <div class="progress"><span id="progress-bar"></span></div>

    <section id="stage" class="card" aria-live="polite"></section>
  </div>

  <script>
    const LETTERS = ["A", "B", "C", "D"];

    const quizData = [
      {
        "q": "Bạn nên dùng thẻ nào để đánh dấu một đoạn văn bản có ý nghĩa quan trọng, nhấn mạnh về mặt ngữ nghĩa (semantic), thay vì chỉ in đậm về mặt hình thức?",
        "options": [
          "<b>",
          "<strong>",
          "<i>",
          "<em>"
        ],
        "correctIndex": 1,
        "explanation": "Thẻ <strong> mang ý nghĩa ngữ nghĩa (semantic) là 'mạnh mẽ/quan trọng' đối với cả người dùng và công cụ tìm kiếm, trong khi thẻ <b> chỉ mang ý nghĩa định dạng là 'in đậm'."
      },
      {
        "q": "Trong trường hợp có nhiều URL dẫn đến cùng một nội dung (trùng lặp nội dung), bạn nên sử dụng thẻ nào để chỉ định URL gốc/chính thức cho công cụ tìm kiếm?",
        "options": [
          "<link rel='prefetch' href='...'>",
          "<link rel='alternate' href='...'>",
          "<link rel='canonical' href='...'>",
          "<meta name='duplication' content='false'>"
        ],
        "correctIndex": 2,
        "explanation": "Thẻ Canonical (<link rel='canonical'>) được sử dụng để giải quyết vấn đề trùng lặp nội dung, nó chỉ ra phiên bản gốc/chính thức của một trang cho công cụ tìm kiếm."
      },
      {
        "q": "Để tối ưu hóa cách bài viết hiển thị khi được chia sẻ trên mạng xã hội như Facebook hoặc Twitter, bạn cần sử dụng bộ thẻ meta nào?",
        "options": [
          "Open Graph (OG) và Twitter Cards",
          "Schema Markup và Rich Snippets",
          "Canonical Tag và Robots Meta",
          "Hreflang và AMP"
        ],
        "correctIndex": 0,
        "explanation": "Open Graph (OG) tags (Facebook) và Twitter Cards kiểm soát tiêu đề, mô tả và hình ảnh khi nội dung được chia sẻ trên các nền tảng xã hội đó."
      },
      {
        "q": "Giả sử bạn có một trang dành cho thiết bị di động (m.) và một trang dành cho máy tính (desktop) với nội dung tương tự. Để giúp Google hiểu mối quan hệ này, bạn cần sử dụng thuộc tính nào trong thẻ <link>?",
        "options": [
          "rel='mobile' và rel='desktop'",
          "rel='index' và rel='follow'",
          "rel='nofollow' và rel='noopener'",
          "rel='alternate' và rel='canonical'"
        ],
        "correctIndex": 3,
        "explanation": "Trang desktop sẽ sử dụng rel='alternate' để trỏ đến trang mobile. Trang mobile sẽ dùng rel='canonical' để trỏ ngược lại trang desktop (hoặc trỏ đến chính nó) để xác định phiên bản chính."
      },
      {
        "q": "Tệp nào được đặt ở thư mục gốc của website, được sử dụng để hướng dẫn các con bot của công cụ tìm kiếm về những khu vực nào trên trang web chúng được phép (hoặc không được phép) thu thập dữ liệu?",
        "options": [
          "favicon.ico",
          "robots.txt",
          "sitemap.xml",
          ".htaccess"
        ],
        "correctIndex": 1,
        "explanation": "Tệp robots.txt là một giao thức loại trừ robot, cho phép quản trị viên web thông báo cho bot về những khu vực nào của trang web không nên được thu thập dữ liệu (crawl)."
      },
      {
        "q": "Để cải thiện tốc độ tải trang bằng cách cho phép trình duyệt tải trước các tài nguyên cần thiết cho trang tiếp theo, bạn nên sử dụng thuộc tính rel nào?",
        "options": [
          "rel=\"stylesheet\"",
          "rel=\"preload\" hoặc rel=\"prefetch\"",
          "rel=\"icon\"",
          "rel=\"dns-prefetch\""
        ],
        "correctIndex": 1,
        "explanation": "`rel=\"preload\"` tải tài nguyên cần thiết cho trang hiện tại. `rel=\"prefetch\"` tải tài nguyên cho trang tiếp theo. Cả hai đều cải thiện tốc độ trải nghiệm người dùng."
      },
      {
        "q": "Thuộc tính loading=\"lazy\" của thẻ <img> ảnh hưởng đến SEO như thế nào?",
        "options": [
          "Tăng kích thước tệp ảnh",
          "Bắt buộc bot phải đợi toàn bộ trang tải xong",
          "Giảm thời gian tải ban đầu bằng cách chỉ tải ảnh khi nó sắp vào viewport.",
          "Không có tác dụng."
        ],
        "correctIndex": 2,
        "explanation": "Lazy loading (tải lười) cải thiện tốc độ tải ban đầu (LCP - Largest Contentful Paint) bằng cách ưu tiên các nội dung trên màn hình đầu tiên, giúp cải thiện trải nghiệm và xếp hạng."
      },
      {
        "q": "Giả sử bạn muốn chèn một video YouTube vào trang của mình, thẻ HTML nào được khuyến nghị để đảm bảo khả năng tương thích và hiển thị tốt trên mọi thiết bị?",
        "options": [
          "<video>",
          "<embed>",
          "<object>",
          "<iframe>"
        ],
        "correctIndex": 3,
        "explanation": "Thẻ <iframe> là cách chuẩn để nhúng nội dung từ bên ngoài (như YouTube) một cách linh hoạt, dễ tương thích và kiểm soát."
      },
      {
        "q": "Sự khác biệt ngữ nghĩa chính giữa thẻ <em> và thẻ <i> là gì?",
        "options": [
          "Không có sự khác biệt",
          "<em> dùng để nhấn mạnh, thay đổi ngữ điệu đọc, còn <i> chỉ là nghiêng chữ.",
          "<i> dùng để nhấn mạnh, còn <em> chỉ là nghiêng chữ",
          "Cả hai đều không nên dùng."
        ],
        "correctIndex": 1,
        "explanation": "Thẻ <em> (emphasis) mang ý nghĩa ngữ nghĩa (bot sẽ hiểu là cần nhấn mạnh), còn thẻ <i> (italic) chỉ mang tính trình bày (nghiêng chữ) mà không có trọng lượng ngữ nghĩa cho bot."
      },
      {
        "q": "Khi sử dụng Pagination (phân trang) trên một loạt bài viết (ví dụ: Trang 1, Trang 2), bạn nên sử dụng cặp thẻ rel nào (hiện đã lỗi thời nhưng vẫn quan trọng để hiểu)?",
        "options": [
          "rel=\"first\" và rel=\"last\"",
          "rel=\"nofollow\" và rel=\"dofollow\"",
          "rel=\"index\" và rel=\"noindex\"",
          "rel=\"prev\" và rel=\"next\""
        ],
        "correctIndex": 3,
        "explanation": "Google đã thông báo ngừng sử dụng cặp thẻ này, nhưng chúng từng được dùng để báo hiệu mối quan hệ tuần tự giữa các trang phân trang, giúp hợp nhất tín hiệu SEO."
      },
      {
        "q": "Thẻ HTML nào là nơi lý tưởng để đặt các liên kết điều hướng chính (như menu)?",
        "options": [
          "<nav>",
          "<footer>",
          "<header>",
          "<section>"
        ],
        "correctIndex": 0,
        "explanation": "Thẻ <nav> được thiết kế ngữ nghĩa để chứa các liên kết điều hướng chính. Việc sử dụng nó giúp các công cụ tìm kiếm và trình đọc màn hình xác định khối điều hướng."
      },
      {
        "q": "Thuộc tính lang trong thẻ <html> có tác dụng gì đối với SEO?",
        "options": [
          "Thay đổi font chữ",
          "Tăng tốc độ tải trang",
          "Khai báo ngôn ngữ chính của tài liệu.",
          "Không có tác dụng."
        ],
        "correctIndex": 2,
        "explanation": "Khai báo ngôn ngữ (`lang`) giúp công cụ tìm kiếm phân loại và hiển thị trang cho người dùng phù hợp với ngôn ngữ của họ, là một phần quan trọng của SEO quốc tế cơ bản."
      },
      {
        "q": "Thẻ meta nào ngăn trình duyệt tự động cố gắng đoán và điều chỉnh chế độ xem trên thiết bị di động?",
        "options": [
          "<meta name=\"viewport\" content=\"minimal-ui\">",
          "<meta name=\"robots\" content=\"noindex\">",
          "<meta name=\"theme-color\">",
          "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">"
        ],
        "correctIndex": 3,
        "explanation": "Thuộc tính `width=device-width, initial-scale=1` là tiêu chuẩn cho thiết kế đáp ứng (responsive), đảm bảo trang hiển thị đúng kích thước trên mọi thiết bị di động."
      },
      {
        "q": "Thẻ HTML nào thích hợp nhất để bọc một khối nội dung độc lập và có ý nghĩa riêng (ví dụ: một bài blog, một bình luận)?",
        "options": [
          "<section>",
          "<article>",
          "<header>",
          "<main>"
        ],
        "correctIndex": 1,
        "explanation": "Thẻ `<article>` có ngữ nghĩa chỉ ra một mục nội dung độc lập, có thể phân phối lại và độc lập với phần còn lại của trang."
      },
      {
        "q": "Khi sử dụng JavaScript để tạo nội dung động, yếu tố nào là rủi ro SEO lớn nhất?",
        "options": [
          "Tăng tốc độ tải trang",
          "Giảm kích thước tệp HTML",
          "Công cụ tìm kiếm không thể hiển thị (render) hoặc lập chỉ mục nội dung JS.",
          "Nội dung trùng lặp."
        ],
        "correctIndex": 2,
        "explanation": "Google phải dành thời gian và tài nguyên để render JS. Nếu có lỗi trong quá trình này hoặc quá trình render diễn ra chậm, nội dung có thể bị bỏ qua hoặc lập chỉ mục không đầy đủ."
      }
    ];

    const stage = document.getElementById("stage");
    const progressBar = document.getElementById("progress-bar");
    const metaProgress = document.getElementById("meta-progress");

    let order = [];
    let current = 0;
    let score = 0;
    let answered = false;

    function shuffle(arr) {
      const a = [...arr];
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function escapeHtml(str) {
      return str.replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;");
    }

    function setProgress() {
      metaProgress.textContent = `${Math.min(current + 1, order.length)}/${order.length}`;
      const pct = (current) / order.length * 100;
      progressBar.style.width = `${pct}%`;
    }

    function renderQuestion() {
      const q = quizData[order[current]];

      const options = q.options.map((text, i) => {
        return `<div class="option" data-index="${i}" role="button" tabindex="0" aria-pressed="false">
  <div class="letter">${LETTERS[i]}</div>
  <div>${escapeHtml(text)}</div>
</div>`;
      }).join("");

      stage.innerHTML = `
        <div class="card-body">
          <div class="q-head">
            <div class="q-index">Câu ${current + 1}/${order.length}</div>
            <div class="q-text">${escapeHtml(q.q)}</div>
          </div>
          <div class="options" id="options">${options}</div>
          <div id="explain" class="explain" aria-live="polite"></div>
        </div>
        <div class="footer">
          <button id="resetBtn" class="btn ghost">Reset</button>
          <div style="display:flex; gap:10px; align-items:center">
            <span class="meta" id="hint">${answered ? "Chọn đáp án để xem giải thích" : ""}</span>
            <button id="nextBtn" class="btn" disabled>Tiếp theo</button>
          </div>
        </div>
      `;

      answered = false;
      bindHandlers();
      setProgress();
    }

    function bindHandlers() {
      const q = quizData[order[current]];
      const list = stage.querySelectorAll(".option");
      const explainBox = stage.querySelector("#explain");
      const nextBtn = stage.querySelector("#nextBtn");
      const resetBtn = stage.querySelector("#resetBtn");

      list.forEach(el => {
        const idx = Number(el.getAttribute("data-index"));
        const select = () => {
          if (answered) return;
          answered = true;

          list.forEach(n => n.classList.remove("selected"));
          el.classList.add("selected");

          const isCorrect = idx === q.correctIndex;
          if (isCorrect) {
            el.classList.add("correct");
            score += 1;
          } else {
            el.classList.add("incorrect");
            const correctEl = Array.from(list)[q.correctIndex];
            correctEl.classList.add("correct");
          }

          const label = isCorrect ? "Chính xác!" : "Chưa chính xác";
          const cls = isCorrect ? "success" : "error";
          const exampleBlock = q.example ? `<pre><code>${escapeHtml(q.example)}</code></pre>` : "";

          explainBox.className = `explain show ${cls}`;
          explainBox.innerHTML = `<div class="label">${label}</div><div>${escapeHtml(q.explanation)}</div>${exampleBlock}`;

          nextBtn.disabled = false;
        };

        el.addEventListener("click", select);
        el.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            select();
          }
        });
      });

      nextBtn.addEventListener("click", nextStep);
      resetBtn.addEventListener("click", resetQuiz);
    }

    function nextStep() {
      if (current < order.length - 1) {
        current += 1;
        renderQuestion();
      } else {
        showSummary();
      }
    }

    function showSummary() {
      progressBar.style.width = "100%";
      metaProgress.textContent = `${order.length}/${order.length}`;

      stage.innerHTML = `
        <div class="summary">
          <div class="score">${score}/${order.length}</div>
          <div class="grid">
            <div class="pill">Đúng: <strong style="color: var(--green)">${score}</strong></div>
            <div class="pill">Sai: <strong style="color: var(--red)">${order.length - score}</strong></div>
          </div>
          <div class="meta">Hoàn thành quiz về HTML Forms. Bạn có thể làm lại để luyện tập thêm.</div>
          <div style="display:flex; justify-content:center; gap:12px; margin-top: 4px;">
            <button class="btn" id="again">Làm lại</button>
          </div>
        </div>
      `;

      const again = document.getElementById("again");
      again.addEventListener("click", resetQuiz);
    }

    function resetQuiz() {
      order = shuffle(quizData.map((_, i) => i));
      current = 0;
      score = 0;
      answered = false;
      renderQuestion();
    }

    // init
    resetQuiz();
  </script>
</body>

</html>